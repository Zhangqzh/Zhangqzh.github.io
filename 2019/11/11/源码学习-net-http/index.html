<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>源码学习-net/http | ZZ blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="Rica Zhang">
  <meta name="keywords" content="ZZ, ZZ Blog, �ō���Ĳ���">
  <meta name="description" content="Whatever will be, will be.">
  <script id="hexo-configurations">
  var CONFIG = {
    root: '/',
    theme: 'Lx',
    version: '1.4.5',
    localsearch:{
      "enable": false,
      "trigger": "auto",
      "top_n_per_article": 1,
      "unescape": false,
      "preload": false
      },
    path: '-'
  };
</script>

  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/main.css">
  <script src="/js/jquery.min.js"></script>
  <script src="/js/jquery.jside.menu.js"></script>
	<script>
	$(document).ready(function(){
	$(".menu-container").jSideMenu({
	    jSidePosition: "position-right",
	    jSideSticky: true,
	    jSideSkin: "endless-river",
	     });
	}); 
	</script>
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:300|Noto+Serif+SC&amp;display=swap">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
</head>
<body>
<div class="single">
<div id="page">
<div id="lx-aside" style="background-image: url(/images/page-cover.jpg)" data-stellar-background-ratio="0.5">
  <div class="overlay">
  <div class="page-title">
    <div class="avatar"><a href="/"><img src="/images/person_1.jpg"></a></div>
    <span>2019-11-11</span>
    <h2>源码学习-net/http</h2>
    
    </div>
</div>
</div>
<div id="lx-main-content">
  <div class="lx-post">
    <div class="lx-entry padding">
      <div>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<h2 id="本文总阅读量次"><a href="#本文总阅读量次" class="headerlink" title="本文总阅读量次"></a><span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span>次</span></h2><p><code>package net/http</code>是Go语言Web应用的基础，学习net/http源码不仅可以学习网络编程中常见范式，也是学习Golang接口设计哲学。通过http包提供了HTTP客户端和服务端的实现。同时使用这个包能很简单地对web的路由，静态文件，模版，cookie等数据进行设置和操作。 </p>
<p><strong>主要涉及以下源码文件</strong>：</p>
<ul>
<li>net/net.go</li>
<li>net/server.go</li>
<li>net/http.go</li>
<li>net/transfer.go</li>
<li>sync/pool.go</li>
<li>sync/mutex.go  </li>
</ul>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><ul>
<li>在HTTP中，客户端总是通过建立一个连接与发送一个HTTP请求来发起一个事务</li>
<li>HTTP协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系的，对HTTP服务器来说，它并不知道这两个请求是否来自同一个客户端。为了解决这个问题， Web程序引入了Cookie机制来维护连接的可持续状态。</li>
</ul>
<h3 id="HTTP请求包（浏览器信息）"><a href="#HTTP请求包（浏览器信息）" class="headerlink" title="HTTP请求包（浏览器信息）"></a>HTTP请求包（浏览器信息）</h3><h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h4><p>Request包分为3部分，第一部分叫Request line（请求行）, 第二部分叫Request header（请求头）,第三部分是body（主体）。header和body之间有个空行，请求包的例子所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /domains/example/ HTTP/1.1		//请求行: 请求方法 请求URI HTTP协议/协议版本</span><br><span class="line">Host：www.iana.org				//服务端的主机名</span><br><span class="line">User-Agent：Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4			//浏览器信息</span><br><span class="line">Accept：text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8	//客户端能接收的MIME</span><br><span class="line">Accept-Encoding：gzip,deflate,sdch		//是否支持流压缩</span><br><span class="line">Accept-Charset：UTF-8,*;q=0.5		//客户端字符编码集</span><br><span class="line">//空行,用于分割请求头和消息体</span><br><span class="line">//消息体,请求资源参数,例如POST传递的参数</span><br></pre></td></tr></table></figure>

<p>HTTP协议定义了很多与服务器交互的请求方法，最基本的有4种，分别是GET,POST,PUT,DELETE。一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，增，改，删4个操作。我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。</p>
<h3 id="HTTP响应包"><a href="#HTTP响应包" class="headerlink" title="HTTP响应包"></a>HTTP响应包</h3><h4 id="Respons"><a href="#Respons" class="headerlink" title="Respons"></a>Respons</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK						//状态行</span><br><span class="line">Server: nginx/1.0.8					//服务器使用的WEB软件名及版本</span><br><span class="line">Date:Date: Tue, 30 Oct 2012 04:14:25 GMT		//发送时间</span><br><span class="line">Content-Type: text/html				//服务器发送信息的类型</span><br><span class="line">Transfer-Encoding: chunked			//表示发送HTTP包是分段发的</span><br><span class="line">Connection: keep-alive				//保持连接状态</span><br><span class="line">Content-Length: 90					//主体内容长度</span><br><span class="line">//空行 用来分割消息头和主体</span><br><span class="line">!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;... //消息体</span><br></pre></td></tr></table></figure>

<h2 id="HTTP网络应用"><a href="#HTTP网络应用" class="headerlink" title="HTTP网络应用"></a>HTTP网络应用</h2><p>理解 HTTP 构建的网络应用只要关注两个端—客户端（clinet）和服务端（server），两个端的交互来自 clinet 的 request，以及server端的response。所谓的http服务器，主要在于如何接受 clinet 的 request，并向client返回response。</p>
<p>接收request的过程中，最重要的莫过于路由（<code>router</code>），即实现一个<code>Multiplexer</code>器。Go中既可以使用内置的<code>mutilplexer</code> — <code>DefautServeMux</code>，也可以自定义。<code>Multiplexer</code>路由的目的就是为了找到处理器函数（<code>handler</code>），后者将对request进行处理，同时构建response。</p>
<p>简单总结就是这个流程为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Clinet -&gt; Requests -&gt;  [Multiplexer(router) -&gt; handler  -&gt; Response -&gt; Clinet</span><br></pre></td></tr></table></figure>

<p>Golang中的Multiplexer基于<code>ServeMux</code>结构，同时也实现了<code>Handler</code>接口</p>
<ul>
<li>hander函数： 具有func(w http.ResponseWriter, r *http.Requests)签名的函数</li>
<li>handler处理器(函数): 经过HandlerFunc结构包装的handler函数，它实现了ServeHTTP接口方法的函数。调用handler处理器的ServeHTTP方法时，即调用handler函数本身。</li>
<li>handler对象：实现了Handler接口ServeHTTP方法的结构。</li>
</ul>
<h1 id="一个简单的web服务器"><a href="#一个简单的web服务器" class="headerlink" title="一个简单的web服务器"></a>一个简单的web服务器</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoServer</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    io.WriteString(w, <span class="string">"Hello, this is a GoServer"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, GoServer)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">":8090"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"ListenAndServer "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册路由"><a href="#注册路由" class="headerlink" title="注册路由"></a>注册路由</h2><p><code>http.HandleFunc(&quot;/&quot;, GoServer)</code>即是在注册路由<br>函数：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出http.HandleFunc选取了DefaultServeMux作为multiplexer  </p>
<h3 id="ServeMux"><a href="#ServeMux" class="headerlink" title="ServeMux"></a>ServeMux</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.RWMutex</span><br><span class="line">    m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">    hosts <span class="keyword">bool</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">    explicit <span class="keyword">bool</span></span><br><span class="line">    h        Handler</span><br><span class="line">    pattern  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>m:一个map，key是一些url模式，value是一个muxEntry结构，muxEntry结构里存储了具体的url模式和handler  </li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle registers the handler for the given pattern.</span></span><br><span class="line"><span class="comment">// If a handler already exists for pattern, Handle panics.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">    mux.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: invalid pattern "</span> + pattern)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mux.m[pattern].explicit &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">    &#125;</span><br><span class="line">    mux.m[pattern] = muxEntry&#123;explicit: <span class="literal">true</span>, h: handler, pattern: pattern&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">        mux.hosts = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Helpful behavior:</span></span><br><span class="line">    <span class="comment">// If pattern is /tree/, insert an implicit permanent redirect for /tree.</span></span><br><span class="line">    <span class="comment">// It can be overridden by an explicit registration.</span></span><br><span class="line">    n := <span class="built_in">len</span>(pattern)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; pattern[n<span class="number">-1</span>] == <span class="string">'/'</span> &amp;&amp; !mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]].explicit &#123;</span><br><span class="line">        <span class="comment">// If pattern contains a host name, strip it and use remaining</span></span><br><span class="line">        <span class="comment">// path for redirect.</span></span><br><span class="line">        path := pattern</span><br><span class="line">        <span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">            <span class="comment">// In pattern, at least the last character is a '/', so</span></span><br><span class="line">            <span class="comment">// strings.Index can't be -1.</span></span><br><span class="line">            path = pattern[strings.Index(pattern, <span class="string">"/"</span>):]</span><br><span class="line">        &#125;</span><br><span class="line">        url := &amp;url.URL&#123;Path: path&#125;</span><br><span class="line">        mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]] = muxEntry&#123;h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServeMux的Handle方法将会对pattern和handler函数做一个map映射，把handler和pattern模式绑定到map[string]muxEntry的map上，其中muxEntry保存了更多pattern和handler的信息  </p>
<h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>go的http服务都是基于handler进行处理，ServeMux使用handler并调用其<code>ServeHTTP</code>方法处理请求并返回相应  </p>
<h3 id="DefaultServeMux"><a href="#DefaultServeMux" class="headerlink" title="DefaultServeMux"></a>DefaultServeMux</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewServeMux allocates and returns a new ServeMux.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServeMux</span><span class="params">()</span> *<span class="title">ServeMux</span></span> &#123; <span class="keyword">return</span> <span class="built_in">new</span>(ServeMux) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultServeMux is the default ServeMux used by Serve.</span></span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br></pre></td></tr></table></figure>

<p>DefaultServeMux是ServeMux的一个实例，默认创建DefaultServeMux，也可以自己 <code>NewServeMux</code>创建</p>
<h3 id="函数调用关系"><a href="#函数调用关系" class="headerlink" title="函数调用关系"></a>函数调用关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc--&gt;  func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))</span><br><span class="line"></span><br><span class="line">--&gt;func (mux *ServeMux) Handle(pattern string, handler Handler)</span><br></pre></td></tr></table></figure>

<h2 id="开始监听"><a href="#开始监听" class="headerlink" title="开始监听"></a>开始监听</h2><p><code>http.ListenAndServe(&quot;:8090&quot;)</code>即是在开启监听<br>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用参数addr和handler创建一个Server类型的变量server，然后调用这个结构体里的成员函数ListenAndServe()  </p>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr         <span class="keyword">string</span>        </span><br><span class="line">    Handler      Handler       </span><br><span class="line">    ReadTimeout  time.Duration </span><br><span class="line">    WriteTimeout time.Duration </span><br><span class="line">    TLSConfig    *tls.Config   </span><br><span class="line"></span><br><span class="line">    MaxHeaderBytes <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    TLSNextProto <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(*Server, *tls.Conn, Handler)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">ConnState</span> <span class="title">func</span><span class="params">(net.Conn, ConnState)</span></span></span><br><span class="line"><span class="function">    <span class="title">ErrorLog</span> *<span class="title">log</span>.<span class="title">Logger</span></span></span><br><span class="line"><span class="function">    <span class="title">disableKeepAlives</span> <span class="title">int32</span>     <span class="title">nextProtoOnce</span>     <span class="title">sync</span>.<span class="title">Once</span> </span></span><br><span class="line"><span class="function">    <span class="title">nextProtoErr</span>      <span class="title">error</span>     </span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Handler:保留Handler接口,如果Server结构没有提供Handler结构对象，那么会使用DefaultServerMux做multiplexer  </li>
</ul>
<h3 id="ListenAndServe"><a href="#ListenAndServe" class="headerlink" title="ListenAndServe"></a>ListenAndServe</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    addr := srv.Addr</span><br><span class="line">    <span class="keyword">if</span> addr == <span class="string">""</span> &#123;</span><br><span class="line">        addr = <span class="string">":http"</span></span><br><span class="line">    &#125;</span><br><span class="line">    ln, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监听srv.Addr指定的TCP网络，并且调用srv.Serve()函数来处理收到的请求,最后将监听的TCP对象传入Serve方法</p>
<h3 id="srv-Serve"><a href="#srv-Serve" class="headerlink" title="srv.Serve"></a>srv.Serve</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> l.Close()</span><br><span class="line">    <span class="keyword">if</span> fn := testHookServerServe; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">        fn(srv, l)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := srv.setupHTTP2_Serve(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> allow changing base context? can't imagine concrete</span></span><br><span class="line">    <span class="comment">// use cases yet.</span></span><br><span class="line">    baseCtx := context.Background()</span><br><span class="line">    ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">    ctx = context.WithValue(ctx, LocalAddrContextKey, l.Addr())</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rw, e := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">                <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">                    tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tempDelay *= <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">                    tempDelay = max</span><br><span class="line">                &#125;</span><br><span class="line">                srv.logf(<span class="string">"http: Accept error: %v; retrying in %v"</span>, e, tempDelay)</span><br><span class="line">                time.Sleep(tempDelay)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        &#125;</span><br><span class="line">        tempDelay = <span class="number">0</span></span><br><span class="line">        c := srv.newConn(rw)</span><br><span class="line">        c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line">        <span class="keyword">go</span> c.serve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>context:一个map，设置一些背景变量，使用方法是：<code>context.WithValue(parentCtx,key,value)</code></li>
<li>for循环:l.Accept()阻塞直到获取到一个<code>net.Conn</code>，之后通过<code>srv.newConn(rw)</code>建立一个<code>server.conn</code>(属于私有变量，不对外暴露)，并设置状态为StateNew</li>
<li>启动goroutine处理连接：调用<code>go c.serve(ctx)</code>。  </li>
</ul>
<h3 id="server-conn"><a href="#server-conn" class="headerlink" title="server.conn"></a>server.conn</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A conn represents the server side of an HTTP connection.</span></span><br><span class="line"><span class="keyword">type</span> conn <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// server is the server on which the connection arrived.</span></span><br><span class="line">    <span class="comment">// Immutable; never nil.</span></span><br><span class="line">    server *Server</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rwc is the underlying network connection.</span></span><br><span class="line">    <span class="comment">// This is never wrapped by other types and is the value given out</span></span><br><span class="line">    <span class="comment">// to CloseNotifier callers. It is usually of type *net.TCPConn or</span></span><br><span class="line">    <span class="comment">// *tls.Conn.</span></span><br><span class="line">    rwc net.Conn</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remoteAddr is rwc.RemoteAddr().String(). It is not populated synchronously</span></span><br><span class="line">    <span class="comment">// inside the Listener's Accept goroutine, as some implementations block.</span></span><br><span class="line">    <span class="comment">// It is populated immediately inside the (*conn).serve goroutine.</span></span><br><span class="line">    <span class="comment">// This is the value of a Handler's (*Request).RemoteAddr.</span></span><br><span class="line">    remoteAddr <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// tlsState is the TLS connection state when using TLS.</span></span><br><span class="line">    <span class="comment">// nil means not TLS.</span></span><br><span class="line">    tlsState *tls.ConnectionState</span><br><span class="line"></span><br><span class="line">    <span class="comment">// werr is set to the first write error to rwc.</span></span><br><span class="line">    <span class="comment">// It is set via checkConnErrorWriter&#123;w&#125;, where bufw writes.</span></span><br><span class="line">    werr error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// r is bufr's read source. It's a wrapper around rwc that provides</span></span><br><span class="line">    <span class="comment">// io.LimitedReader-style limiting (while reading request headers)</span></span><br><span class="line">    <span class="comment">// and functionality to support CloseNotifier. See *connReader docs.</span></span><br><span class="line">    r *connReader</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bufr reads from r.</span></span><br><span class="line">    <span class="comment">// Users of bufr must hold mu.</span></span><br><span class="line">    bufr *bufio.Reader</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bufw writes to checkConnErrorWriter&#123;c&#125;, which populates werr on error.</span></span><br><span class="line">    bufw *bufio.Writer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lastMethod is the method of the most recent request</span></span><br><span class="line">    <span class="comment">// on this connection, if any.</span></span><br><span class="line">    lastMethod <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mu guards hijackedv, use of bufr, (*response).closeNotifyCh.</span></span><br><span class="line">    mu sync.Mutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hijackedv is whether this connection has been hijacked</span></span><br><span class="line">    <span class="comment">// by a Handler with the Hijacker interface.</span></span><br><span class="line">    <span class="comment">// It is guarded by mu.</span></span><br><span class="line">    hijackedv <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>mu类型是<code>sync.Mutex</code>,mu就是持有对象锁的那个实例。可以看到conn的hijackedv属性就是通过mu来进行维护的，目的是防止同步更新问题。  </li>
</ul>
<h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><h3 id="conn-serve"><a href="#conn-serve" class="headerlink" title="conn.serve"></a>conn.serve</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serve a new connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">serve</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    c.remoteAddr = c.rwc.RemoteAddr().String()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> size = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">            buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">            buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line">            c.server.logf(<span class="string">"http: panic serving %v: %v\n%s"</span>, c.remoteAddr, err, buf)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !c.hijacked() &#123;</span><br><span class="line">            c.<span class="built_in">close</span>()</span><br><span class="line">            c.setState(c.rwc, StateClosed)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tlsConn, ok := c.rwc.(*tls.Conn); ok &#123;</span><br><span class="line">        <span class="keyword">if</span> d := c.server.ReadTimeout; d != <span class="number">0</span> &#123;</span><br><span class="line">            c.rwc.SetReadDeadline(time.Now().Add(d))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> d := c.server.WriteTimeout; d != <span class="number">0</span> &#123;</span><br><span class="line">            c.rwc.SetWriteDeadline(time.Now().Add(d))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := tlsConn.Handshake(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            c.server.logf(<span class="string">"http: TLS handshake error from %s: %v"</span>, c.rwc.RemoteAddr(), err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.tlsState = <span class="built_in">new</span>(tls.ConnectionState)</span><br><span class="line">        *c.tlsState = tlsConn.ConnectionState()</span><br><span class="line">        <span class="keyword">if</span> proto := c.tlsState.NegotiatedProtocol; validNPN(proto) &#123;</span><br><span class="line">            <span class="keyword">if</span> fn := c.server.TLSNextProto[proto]; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">                h := initNPNRequest&#123;tlsConn, serverHandler&#123;c.server&#125;&#125;</span><br><span class="line">                fn(c.server, tlsConn, h)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HTTP/1.x from here on.</span></span><br><span class="line"></span><br><span class="line">    c.r = &amp;connReader&#123;r: c.rwc&#125;</span><br><span class="line">    c.bufr = newBufioReader(c.r)</span><br><span class="line">    c.bufw = newBufioWriterSize(checkConnErrorWriter&#123;c&#125;, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    ctx, cancelCtx := context.WithCancel(ctx)</span><br><span class="line">    <span class="keyword">defer</span> cancelCtx()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        w, err := c.readRequest(ctx)</span><br><span class="line">        <span class="keyword">if</span> c.r.remain != c.server.initialReadLimitSize() &#123;</span><br><span class="line">            <span class="comment">// If we read any bytes off the wire, we're active.</span></span><br><span class="line">            c.setState(c.rwc, StateActive)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err == errTooLarge &#123;</span><br><span class="line">                <span class="comment">// Their HTTP client may or may not be</span></span><br><span class="line">                <span class="comment">// able to read this if we're</span></span><br><span class="line">                <span class="comment">// responding to them and hanging up</span></span><br><span class="line">                <span class="comment">// while they're still writing their</span></span><br><span class="line">                <span class="comment">// request. Undefined behavior.</span></span><br><span class="line">                io.WriteString(c.rwc, <span class="string">"HTTP/1.1 431 Request Header Fields Too Large\r\nContent-Type: text/plain\r\nConnection: close\r\n\r\n431 Request Header Fields Too Large"</span>)</span><br><span class="line">                c.closeWriteAndWait()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// don't reply</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> neterr, ok := err.(net.Error); ok &amp;&amp; neterr.Timeout() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// don't reply</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> publicErr <span class="keyword">string</span></span><br><span class="line">            <span class="keyword">if</span> v, ok := err.(badRequestError); ok &#123;</span><br><span class="line">                publicErr = <span class="string">": "</span> + <span class="keyword">string</span>(v)</span><br><span class="line">            &#125;</span><br><span class="line">            io.WriteString(c.rwc, <span class="string">"HTTP/1.1 400 Bad Request\r\nContent-Type: text/plain\r\nConnection: close\r\n\r\n400 Bad Request"</span>+publicErr)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Expect 100 Continue support</span></span><br><span class="line">        req := w.req</span><br><span class="line">        <span class="keyword">if</span> req.expectsContinue() &#123;</span><br><span class="line">            <span class="keyword">if</span> req.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &amp;&amp; req.ContentLength != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// Wrap the Body reader with one that replies on the connection</span></span><br><span class="line">                req.Body = &amp;expectContinueReader&#123;readCloser: req.Body, resp: w&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> req.Header.get(<span class="string">"Expect"</span>) != <span class="string">""</span> &#123;</span><br><span class="line">            w.sendExpectationFailed()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HTTP cannot have multiple simultaneous active requests.[*]</span></span><br><span class="line">        <span class="comment">// Until the server replies to this request, it can't read another,</span></span><br><span class="line">        <span class="comment">// so we might as well run the handler in this goroutine.</span></span><br><span class="line">        <span class="comment">// [*] Not strictly true: HTTP pipelining. We could let them all process</span></span><br><span class="line">        <span class="comment">// in parallel even if their responses need to be serialized.</span></span><br><span class="line">        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">        w.cancelCtx()</span><br><span class="line">        <span class="keyword">if</span> c.hijacked() &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        w.finishRequest()</span><br><span class="line">        <span class="keyword">if</span> !w.shouldReuseConnection() &#123;</span><br><span class="line">            <span class="keyword">if</span> w.requestBodyLimitHit || w.closedRequestBodyEarly() &#123;</span><br><span class="line">                c.closeWriteAndWait()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.setState(c.rwc, StateIdle)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化bufr和bufw</li>
<li>从底层读取客户端发送的数据</li>
<li>调用用户的handler：<code>serverHandler{c.server}.ServeHTTP(w, w.req)</code>，这句实际上调用的是<code>c.server.Handler.ServeHTTP()</code>。Handler就是DefaultServeMux或者用户指定的ServeMux，根据用户定义路由规则，来具体调用用户的业务逻辑方法。</li>
<li>处理工作：异常处理，资源回收，状态更新。<br>参考链接：<a href="https://blog.csdn.net/HOMERUNIT/article/details/78518430" target="_blank" rel="noopener">http/net的源码解读</a></li>
</ul>

      </div>
    </div>
  </div>
</div>
<div class="lx-navigation">
	<div class="lx-cover prev lx-cover-sm" style="background-image: url(/images/footer_1.jpg)">
		<div class="overlay"></div>
		<a class="copy" href="/2019/11/20/博客网站REST-API设计/">
			<div class="display-t">
				<div class="display-tc">
					<div>
						<span>Next</span>
						<h3>博客网站REST API设计</h3>
					</div>
				</div>
			</div>
		</a>
	</div>
        <div class="lx-cover next lx-cover-sm" style="background-image: url(/images/footer_2.jpg)">
		<div class="overlay"></div>
		<a class="copy" href="/2019/11/11/cloudgo/">
			<div class="display-t">
				<div class="display-tc">
					<div>
						<span>Prev</span>
						<h3>cloudgo</h3>
					</div>
				</div>
			</div>
		</a>
	</div>
</div>
</div>

<footer>
  <div>
  Copyright &copy; 2019.<a href="/">ZZ blog</a><br>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme <a href="https://lx.blleng.cn" target="_blank">Lx</a><br>
  </div>
</footer>
</div>

<button class="menu-trigger"></button>
<div class="menu">
  <div class="menu-head">
    <span class="layer">
      <div class="col">
        <div class="row for-pic">
          <div class="profile-pic">
            <a href="/"><img src="/images/person_1.jpg" alt="Rica Zhang"></a>
          </div>
        </div>
        <div class="row for-name">
          <p>Rica Zhang</p>
          <span class="tagline">Hello, World!</span>
        </div>
      </div>
    </span>
  </div>
  <nav class="menu-container">
  <ul class="menu-items">
    <li><a href="/"><i class="fa fa-home fa-fw"></i>首页</a></li>
    <li><a href="/archives/"><i class="fa fa-archive fa-fw"></i>归档</a></li>
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-bookmark fa-fw"></i>页面</span>
        <ul>
          <li><a href="/guestbook">留言</a></li>
        <li><a href="/about">关于</a></li>
        </ul>
    </li>
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-link fa-fw"></i>友链</span>
        <ul>
          <li> <a href="https://lx.blleng.cn" target="_blank">Theme-Lx</a></li>
        </ul>
    </li>
  </ul>
  </nav>
</div>

<div class="gototop js-top">
  <a href="#" class="js-gotop"><i class="fa fa-arrow-up"></i></a>
</div>
<script src="/js/jquery.easing.min.js"></script>
<script src="/js/jquery.waypoints.min.js"></script>
<script src="/js/jquery.stellar.min.js"></script>
<script src="/js/main.js"></script>


</body>
</html>
